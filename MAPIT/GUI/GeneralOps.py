from MAPIT.GUI import ThreadTools, StatsPanelOps, DialogComponents
from PySide6 import QtCore,QtWidgets, QtGui
import os
import numpy as np
from pathlib import Path
import sys
import csv
from scipy.io import savemat, loadmat
import pickle
from datetime import datetime
import queue
import json
from platformdirs import user_data_dir
import site


def SaveStats(self, AnalysisData, GUIparams):
    """
            This function exports
            results generated by MAPIT
            to (potentially multiple)
            .csv files.
    """

    #create a directory for output if doesnt exist
    t = datetime.now()
    s = "%s%s%s%s%s%s" % (t.year, t.month, t.day, t.hour, t.minute, t.second)
    outdir = os.path.join(user_data_dir('MAPIT',False),'output',s)

    if not os.path.isdir(outdir):
      os.mkdir(outdir)



    self.PB.setMaximum(0)
    self.PB.setMinimum(0)
    #self.StatDlg.UpdateDispText('Saving Data')
    self.PB.setFormat('Saving data')
    QtCore.QCoreApplication.instance().processEvents()


    #TODO: add output format options for tests as
    # currently only different formats for
    # process data is supported

    QtCore.QCoreApplication.instance().processEvents(
    )  #makes sure the GUI doesnt look frozen

    if hasattr(AnalysisData,'MUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_MUF.csv'),
        AnalysisData.MUF.T,
        delimiter=',')

    if hasattr(AnalysisData,'CUMUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_CUMUF.csv'),
        AnalysisData.CUMUF.T,
        delimiter=',')


    if hasattr(AnalysisData,'SEMUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_SEID.csv'),
        AnalysisData.SEMUF.T,
        delimiter=',')


    if hasattr(AnalysisData,'SITMUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_SITMUF.csv'),
        AnalysisData.SITMUF.T,
        delimiter=',')

    if hasattr(AnalysisData,'Page'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_SITMUF_Page.csv'),
        AnalysisData.Page.T,
        delimiter=',')
    # print observed data
    #future TODO
    #will require some extra thought for
    #how to handle non-uniformly sampled data
    #save to .xlsx? separate .csv for time?

    CheckPrint = QtWidgets.QMessageBox(self)
    CheckPrint.setText('Save observed data?')
    CheckPrint.setInformativeText(
        'Observed data is the user supplied ground truth with applied specified errors'
    )
    CheckPrint.setStandardButtons(QtWidgets.QMessageBox.Yes
                                  | QtWidgets.QMessageBox.No)

    #this reorders the buttons from the default no,yes to yes,no
    hlay = CheckPrint.findChild(QtWidgets.QHBoxLayout)
    litem = hlay.takeAt(1)
    w = litem.widget()
    hlay.addWidget(w)
    CPE = CheckPrint.exec_()



    ck1 = self.CB_MUF.isChecked() + self.CB_SMUF.isChecked(
    ) + self.CB_SITMUF.isChecked() + self.CB_PAGE.isChecked() +\
    self.CB_CUMUF.isChecked()



    # [iter, location, timestep, element]
    #if labels exist use them to help
    #write the name of the output files
    if QtWidgets.QMessageBox.Yes == CPE:

      getOutType = QtWidgets.QMessageBox()
      getOutType.setText('Select output format.')
      getOutType.setInformativeText(
        'Order by iteration: Group data into run iteration, better for manual human analysis \n \n' \
        'Order by location: Group data by location, better for importing into secondary analytical pipelines')
    


      buttonCSVL = getOutType.addButton('.csv: by location',QtWidgets.QMessageBox.ResetRole) #this is arbitrary, but if accept and reject roles aren't present then the red X to close the dialog wont work
      buttonCSVI = getOutType.addButton('.csv: by iteration',QtWidgets.QMessageBox.ApplyRole)
      buttonNPZ = getOutType.addButton('.npz archive',QtWidgets.QMessageBox.RejectRole)
      buttonMAT = getOutType.addButton('.mat archive', QtWidgets.QMessageBox.NoRole)
      buttonPKL = getOutType.addButton('.pkl archive', QtWidgets.QMessageBox.NoRole)


      CT = getOutType.exec_()
      
      IT = AnalysisData.inputAppliedError[0].shape[0]
      if getOutType.clickedButton() == buttonCSVL:
        
        headers = np.empty((IT+1,),dtype='U13')
        headers[0] = 'Time'
        for J in range(IT):
          headers[J+1] = 'Iteration ' + str(J)

        

        #by run or by location
        #by location here
        for J in range(len(AnalysisData.inputAppliedError)):
          holder = headers.reshape((-1,1))
          holder = np.concatenate((holder,
            np.concatenate((AnalysisData.rawInputTimes[J].reshape((1,-1)),np.squeeze(AnalysisData.inputAppliedError[J])),axis=0,dtype='U13')),axis=1)

          np.savetxt(
            os.path.join(outdir,GUIparams.TestType+'_Input'+str(J)+'.csv'),
            holder.T,
            delimiter=',',
            fmt="%s")

          QtCore.QCoreApplication.instance().processEvents()

        for J in range(len(AnalysisData.inventoryAppliedError)):
          holder = headers.reshape((-1,1))
          holder = np.concatenate((holder,
            np.concatenate((AnalysisData.rawInventoryTimes[J].reshape((1,-1)),np.squeeze(AnalysisData.inventoryAppliedError[J])),axis=0,dtype='U13')),axis=1)

          np.savetxt(
            os.path.join(outdir,GUIparams.TestType+'_Inventory'+str(J)+'.csv'),
            holder.T,
            delimiter=',',
            fmt="%s")

          QtCore.QCoreApplication.instance().processEvents()

        for J in range(len(AnalysisData.outputAppliedError)):
          holder = headers.reshape((-1,1))
          holder = np.concatenate((holder,
            np.concatenate((AnalysisData.rawOutputTimes[J].reshape((1,-1)),np.squeeze(AnalysisData.outputAppliedError[J])),axis=0,dtype='U13')),axis=1)

          np.savetxt(
            os.path.join(outdir,GUIparams.TestType+'_Output'+str(J)+'.csv'),
            holder.T,
            delimiter=',',
            fmt="%s")

          QtCore.QCoreApplication.instance().processEvents()

      elif getOutType.clickedButton() == buttonCSVI:
        

        for J in range(IT): #IT

          h = []
          spacer = ['']

          for K in range(len(AnalysisData.inputAppliedError)):
            
            h.append(AnalysisData.rawInputTimes[K].tolist()) 
            h[-1].insert(0,'input'+str(K))
            h.append(np.squeeze(AnalysisData.inputAppliedError[K][J,]).tolist())
            h[-1].insert(0,'time')
            h.append(spacer)
            
          
          for K in range(len(AnalysisData.inventoryAppliedError)):

            h.append(AnalysisData.rawInventoryTimes[K].tolist()) 
            h[-1].insert(0,'inventory'+str(K))
            h.append(np.squeeze(AnalysisData.inventoryAppliedError[K][J,]).tolist())
            h[-1].insert(0,'time')
            h.append(spacer)
            
          
          for K in range(len(AnalysisData.outputAppliedError)):

            h.append(AnalysisData.rawOutputTimes[K].tolist()) 
            h[-1].insert(0,'output'+str(K))
            h.append(np.squeeze(AnalysisData.outputAppliedError[K][J,]).tolist())
            h[-1].insert(0,'time')
            h.append(spacer)
            


          # export_data = zip_longest(*h, fillvalue = None)
          # with open(os.path.join(outdir,GUIparams.TestType+'_Iteration'+str(J)+'.csv'), 'w', ) as myfile:
          #   wr = csv.writer(myfile)
          #   wr.writerows(export_data)

          with open(os.path.join(outdir,GUIparams.TestType+'_Iteration'+str(J)+'.csv'), 'w', ) as myfile:
            wr = csv.writer(myfile)
            for word in h:
              wr.writerow(word)

      elif getOutType.clickedButton() == buttonNPZ:
        
        
        #because of the headaches of ragged arrays it's easiest to store
        #at each location rather than per iteration (which is ideal), so
        #maybe this can be improved in the future


        
        for K in range(len(AnalysisData.inputAppliedError)):
            t = AnalysisData.rawInputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inputAppliedError[K])
            np.savez(os.path.join(outdir,GUIparams.TestType+'input'+str(K)+'.npz'),
            time = t,
            values = x)

        for K in range(len(AnalysisData.inventoryAppliedError)):
            t = AnalysisData.rawInventoryTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inventoryAppliedError[K])
            np.savez(os.path.join(outdir,GUIparams.TestType+'inventory'+str(K)+'.npz'),
            time = t,
            values = x)

        for K in range(len(AnalysisData.outputAppliedError)):
            t = AnalysisData.rawOutputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.outputAppliedError[K])
            np.savez(os.path.join(outdir,GUIparams.TestType+'output'+str(K)+'.npz'),
            time = t,
            values = x)




      elif getOutType.clickedButton() == buttonMAT:

        

        for K in range(len(AnalysisData.inputAppliedError)):
            t = AnalysisData.rawInputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inputAppliedError[K])
            mdict = {"time": t, "values": x}
            savemat(os.path.join(outdir,GUIparams.TestType+'input'+str(K)+'.mat'),mdict)

        for K in range(len(AnalysisData.inventoryAppliedError)):
            t = AnalysisData.rawInventoryTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inventoryAppliedError[K])
            mdict = {"time": t, "values": x}
            savemat(os.path.join(outdir,GUIparams.TestType+'inventory'+str(K)+'.mat'),mdict)

        for K in range(len(AnalysisData.outputAppliedError)):
            t = AnalysisData.rawOutputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.outputAppliedError[K])
            mdict = {"time": t, "values": x}
            savemat(os.path.join(outdir,GUIparams.TestType+'output'+str(K)+'.mat'),mdict)

      elif getOutType.clickedButton() == buttonPKL:

        for J in range(IT): #IT

          x = []
          t = []


          for K in range(len(AnalysisData.inputAppliedError)):
            
            t.append(AnalysisData.rawInputTimes[K].tolist()) 
            x.append(np.squeeze(AnalysisData.inputAppliedError[K][J,]).tolist())


            
          
          for K in range(len(AnalysisData.inventoryAppliedError)):

            t.append(AnalysisData.rawInventoryTimes[K].tolist()) 
            x.append(np.squeeze(AnalysisData.inventoryAppliedError[K][J,]).tolist())


            
          
          for K in range(len(AnalysisData.outputAppliedError)):

            t.append(AnalysisData.rawOutputTimes[K].tolist()) 
            x.append(np.squeeze(AnalysisData.outputAppliedError[K][J,]).tolist())

          with open(os.path.join(outdir,GUIparams.TestType+'_Iteration'+str(J)+'.pkl'), 'wb') as f:
            pickle.dump([x,t],f)

      else:
        None










    self.PB.setMaximum(100)
    self.PB.setValue(100)
    #self.StatDlg.UpdateDispText('Execution Finished')
    self.PB.setFormat('Execution finished')
    
def checkImportAxes(d):
  if d.shape[0] < d.shape[1]:
    np.swapaxes(d,0,1)
  
  return d

def getExtData(self,AnalysisData,GUIparams,Wizard):
  inpdict={"AnalysisData":AnalysisData, "GUIparams":GUIparams, "Wizard":Wizard}
  Q=queue.Queue()
  thread = ThreadTools.getExtData(Q,grabExt,parent=self)
  thread.finished.connect(thread.deleteLater)
  thread.start()
  Q.put(inpdict)

def grabExt(result):
  AnalysisData, GUIparams, Wizard, GUIObj, indat, inTdat, invdat, invTdat, outdat, outTdat = result

  AnalysisData.rawInput, AnalysisData.rawInputTimes, \
  AnalysisData.rawInventory, AnalysisData.rawInventoryTimes, \
  AnalysisData.rawOutput, AnalysisData.rawOutputTimes = indat, inTdat, invdat, invTdat, outdat, outTdat

  GUIparams.nInputLocations, GUIparams.nInventoryLocations, \
  GUIparams.nOutputLocations, GUIparams.nTotalLocations, \
  GUIparams.rowNames = processWizardGUI(AnalysisData,Wizard)
  GUIparams.ExtData = True



  GUIparams.nInferredEles = 1

  if Wizard.EleIsoName != "":
    GUIparams.eleList = Wizard.EleIsoName
  else:    
    GUIparams.eleList = 'element0'

  StatsPanelOps.enable_setup_controls(GUIObj)

  entries = []
  bypass = False
  for n in GUIparams.rowNames:
    if n == '':
      bypass = not bypass
    if bypass == False and n != '': # skip inventories
      entries.append(n)

  typeWizard = DialogComponents.getImportDataTypeDlg(entries, GUIObj.colordict)
  typeWizard.exec()
  types = typeWizard.get_types()
  AnalysisData.inputTypes = types[:GUIparams.nInputLocations]
  AnalysisData.outputTypes = types[GUIparams.nInputLocations:]



def processWizardGUI(AnalysisData,WizardObj):
  ninputloc = len(AnalysisData.rawInput)
  ninvloc = len(AnalysisData.rawInventory)
  noutloc = len(AnalysisData.rawOutput)
  ntotalloc = ninputloc + ninvloc + noutloc

  innames = []
  invnames = []
  outnames = []
  if len(WizardObj.InKMP_names) != ninputloc:
    for i in range(ninputloc):
      innames.append('input'+str(i))
  else:
    innames = WizardObj.InKMP_names
  
  if len(WizardObj.InvKMP_names) != ninvloc:
    for i in range(ninvloc):
      invnames.append('inventory'+str(i))
  else:
    invnames = WizardObj.InvKMP_names
  
  if len(WizardObj.OutKMP_names) != noutloc:
    for i in range(noutloc):
      outnames.append('output'+str(i))
  else:
    outnames = WizardObj.OutKMP_names

  spacer = ['']
  rownames = innames + spacer + invnames + spacer + outnames #lists


  return ninputloc, ninvloc, noutloc, ntotalloc, rownames



def getSceneData(GUIObj,AnalysisData,GUIparams):

  GUIObj.CB_ErrorProp.setEnabled(0)
  GUIObj.CB_ErrorProp.setChecked(1)
  GUIObj.IterBox.setEnabled(1)
  
  setnames = {
              "Normal": "Normal",
              "Abrupt Loss": "Abrupt",
              "Protracted Loss":"Protract"
            }

  mdl_names = {
                "Fuel Fab":"fuel_fab"
            }

  if GUIObj.mdlopts.currentText() == "" or GUIObj.datopts.currentText() == "":
    F = os.path.join(GUIparams.exemplarDataPath, mdl_names[list(mdl_names.keys())[0]], setnames[list(setnames.keys())[0]], 'data.mat')
  else:
    F = os.path.join(GUIparams.exemplarDataPath, mdl_names[GUIObj.mdlopts.currentText()], setnames[GUIObj.datopts.currentText()], 'data.mat')
  x1 = loadmat(F,squeeze_me=True)

  AnalysisData.rawInventory = x1['invn']['data']
  AnalysisData.rawInput = x1['in']['data']
  AnalysisData.rawOutput = x1['outn']['data']

  AnalysisData.rawInventoryTimes = x1['invn']['time']
  AnalysisData.rawInputTimes = x1['in']['time']
  AnalysisData.rawOutputTimes = x1['outn']['time']

  GUIparams.sceneName = GUIObj.mdlopts.currentText()
  GUIparams.nInputLocations = np.shape(AnalysisData.rawInput)[0]
  GUIparams.nInventoryLocations =  np.shape(AnalysisData.rawInventory)[0]
  GUIparams.nOutputLocations = np.shape(AnalysisData.rawOutput)[0]
  GUIparams.nTotalLocations = np.shape(AnalysisData.rawInput)[0] + np.shape(AnalysisData.rawInventory)[0] + np.shape(AnalysisData.rawOutput)[0]
  GUIparams.ExtData = False

  AnalysisData.inputTypes = ['continuous']*GUIparams.nInputLocations
  AnalysisData.outputTypes = ['continuous']*GUIparams.nOutputLocations


  GUIparams.eleList = ['U']
  GUIparams.nInferredEles = 1

  #disable some checkboxes for fuel fab scenario
  #fuel fab only has uranium and some other
  #non actinide materials

  if GUIObj.mdlopts.currentText() == "" or GUIObj.datopts.currentText() == "":
    F = os.path.join(GUIparams.exemplarDataPath, mdl_names[list(mdl_names.keys())[0]], setnames[list(setnames.keys())[0]], 'auxData.npz')
  else:
    F = os.path.join(GUIparams.exemplarDataPath, mdl_names[GUIObj.mdlopts.currentText()], setnames[GUIObj.datopts.currentText()], 'auxData.npz')
  A = np.load(F)
  GUIparams.rowNames = A['arr2']
  GUIObj.GESelector.addItem("U")
  #self.liH = ['U'] 
  GUIparams.eleList = ['U']
  GUIparams.nInferredEles = 1





  return AnalysisData, GUIparams

def loadDataLabels(GUIparams):
  with open(os.path.join(site.getsitepackages()[-1], 'MAPIT', 'labels','exemplarMdls'+'.json'),'r') as fp:
    GUIparams.availableMdls = json.load(fp)

  with open(os.path.join(site.getsitepackages()[-1], 'MAPIT', 'labels','exemplarDatas'+'.json'),'r') as fp:
    GUIparams.availableDatas = json.load(fp)

def updateDataGUIOptions(GUIobject, GUIparams):
  existingDatas = [GUIobject.datopts.itemText(i) for i in range(GUIobject.datopts.count())]
  for lab in GUIparams.availableDatas:
    if GUIparams.availableDatas[lab] not in existingDatas:
      GUIobject.datopts.addItem(GUIparams.availableDatas[lab])

  existingMdls = [GUIobject.mdlopts.itemText(i) for i in range(GUIobject.mdlopts.count())]
  for lab in GUIparams.availableMdls:
    if GUIparams.availableMdls[lab] not in existingMdls:
      GUIobject.mdlopts.addItem(GUIparams.availableMdls[lab])

def loadGUILabels(GUIparams,international=False):
  if international == True:
      dictname = 'intLabels'
  else:
    dictname = 'domLabels'

  with open(os.path.join(site.getsitepackages()[-1], 'MAPIT','labels',dictname+'.json'),'r') as fp:
    labels = json.load(fp)


  GUIparams.labels = labels

  return GUIparams
